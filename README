
Usage instructions:

    1) Open the system terminal and navigate to the directory containing the <src> folder.
       Create the folder <build> if it doesn't exist already.

    2) Compile the files:
        javac -d build -cp src src/*.java
        
    3) Enter the build folder:
        cd build

    4) Create the executable jar:
        jar cfe <jar name>.jar Main Main.class core/*.class core/types/*.class core/comparators/*.class gui/*.class parser/*.class
        
    5) Use the executable jar:
        java -jar <jar name>.jar <input file> [-v]

          <input file>      path to the input file (required)
                    -v      enable visualizer (optional)
    
    
Code analysis:
    
    - Data structures

        Sweep Line Status: TreeSet<E>
          Extract from the Javadoc (https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html):
          "This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains)"

          The methods used in the algorithm core implementation are:
            o add(E e)          O(log(n))
            o remove(E e)       O(log(n))
            o lower(E e)        O(log(n))
            o higher(E e)       O(log(n))

          Based on the fact that the operation remove(E e) takes log(n) time and it must navigate the tree to find the
          element to remove, with the same logic instead of removing such element it can return it's neighbours values
          in O(1) time, making lower(E e) and higher(E e) also take log(n) time.

          The methods used for debugging and to display data are:
            o size()            O(1)
            o descendingSet()   O(n)
            o iterator()        O(n)

          These methods can be omitted when calculating the algorithm time complexity as they do not provide required
          functionalities.

        Events: PriorityQueue<E>
          Extract from the Javadoc (https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html):
          "this implementation provides O(log(n)) time for the enqueing and dequeing methods (offer, poll, remove
           and add); linear time for the remove(Object) and contains(Object) methods; and constant time for the
           retrieval methods (peek, element, and size)"

           The methods used in the algorithm core implementation are:
             o add(E e)         O(log(n))
             o poll()           O(log(n))
             o isEmpty()        O(1)
             o iterator()       O(n)
             o remove(E e)      O(n)

